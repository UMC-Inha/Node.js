### 🎯핵심 키워드
---
- TCP
    - Transport layer에서 사용하는 프로토콜
    - 장치들 사이에 논리적인 접속을 성립(Establish)하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스
    - 3-way handshaking 과정을 통해 연결을 설정한다.
        1. 클라이언트가 서버에 SYN을 보내고 SYN_SENT 상태로 대기한다.
        2. 서버는 SYN_RCVD 상태로 바꾸고 SYN과 응답 ACK를 보낸다.
        3. SYN과 응답 ACK을 받은 클라이언트는 ”Established” 상태로 변경하고 서버에게 응답 ACK를 보낸다.
        4. 응답 ACK를 받은 서버는 ”Established” 상태로 변경한다.
    - 신뢰성이 높은 전송을 보장한다.
        - 정상적인 상황에서는 ACK이 연속적으로 전송된다. 그러나 ACK이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다.
        - 일정 시간 동안 ACK 값이 수신을 못할 경우 재전송을 요청한다.
- UDP
    - User Datagram Protocol
    - 일방적이며 비연결지향형 프로토콜이다.
    - 순서 및 데이터 전송이 보장되지 않으며 TCP에 비해 빠르다.
    - 간단한 데이터를 빠른 속도로 전송하고자 하는 애플리케이션에서는 UDP를 사용한다.
- 시스템 콜
    - 운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스
    - 사용자 프로그램이 특권 명령(커널 모드)의 수행을 필요로 하는 경우, 운영체제에게 특권 명령의 대행을 요청한다.
    1. 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성되는 시스템 콜 테이블을 유지한다.
    2. 운영체제는 자신의 커널 영역에서 해당 인덱스가 가리키는 주소에 저장되어 있는 루틴을 수행한다.
    3. 작업이 완료되면 CPU에게 인터럽트를 발생시켜 수행이 완료되었음을 알린다.
- 하드웨어 인터럽트
    - 하드웨어가 발생시키는 인터럽트
        - 인터럽트
            1. CPU가 입출력 작업을 요청한 후 그 작업을 완료할 때까지 기다리는 동안 다른 작업을 수행한다(비동기 처리, 멀티태스킹).
            2. 이 과정에서 CPU는 입출력 작업을 기다리지 않고 다른 프로세스나 스레드를 처리하며 CPU가 쉬는 시간을 최소화한다.
            3. 입출력 작업이 완료되면 입출력 장치(ex. 디스크, 네트워크 장치 등)가 인터럽트를 CPU에 보내고 이 인터럽트는 CPU에게 입출력 작업이 완료되었음을 알린다.
            4. CPU는 이를 처리하여 해당 작업의 후속 작업을 이어갈 수 있다.
    - CPU가 아닌 다른 하드웨어 장치가 CPU에 어떤 사실을 알려주거나 CPU 서비스를 요청해야 할 경우 발생시킨다.
- 리눅스의 파일과 파일 디스크립터
    - 리눅스의 파일
        - 리눅스에서는 모든 것을 파일(프로세스 = 파일, 디렉토리 = 파일, App 프로세스 = 파일, ….)로 취급하며 소켓 또한 파일로 취급한다.
    - 파일 디스크립터
        - 리눅스 혹은 유닉스 시스템에서 프로세스가 파일을 다룰 때 사용하는 것으로 운영체제가 특정 파일에 할당해주는 정수값
        - ex. 파일 디스크립터 값이 할당된 입출력
            - stdin(표준입력) : 0 / stdout(표준출력) : 1 / stderr(표준에러) : 2
- socket() 시스템 콜
    - socket(IP 주소 체계, 서비스 타입, 프로토콜)
    - IPv4 통신(또는 IPv6 통신)을 위해 사용할지, TCP(또는 UDP)를 사용할지 미리 틀을 만들어두는 시스템 콜 → 소켓 생성
- bind() 시스템 콜
    - bind(바인딩할 소켓, 바인딩할 소켓의 IP 주소, 소켓 IP 주소의 크기)
    - 네트워크 통신을 위해 필요한 IP 주소와 port 번호를 고정해서 지정해 주는 시스템 콜
    - 서버와 클라이언트는 1 : N 관계인데, 서버가 마음대로 IP 주소와 port 번호를 바꾸면 N에 해당하는 클라이언트는 혼동이 오기 때문에 서버는 IP 주소와 포트 번호가 고정되어야 한다(bind). 그러나 클라이언트는 그럴 필요가 없어 bind 시스템 콜이 없다(클라이언트는 통신 시 port 번호가 자동으로 부여된다).
- listen() 시스템 콜
    - listen(소켓, TCP의 백로그 큐의 크기)
    - 소켓을 클라이언트의 연결 요청을 받아들이도록 하며 backlog 크기만큼 backlog queue를 만드는 시스템 콜
        - backlog: TCP에서의 backlog queue의 크기
        - backlog queue: 클라이언트가 서버에 보내는 요청들을 저장하는 대기열
    - 연결지향인 TCP에서만 사용된다.
    - listen 시스템 콜을 통해 TCP를 연결 요청을 받아줄 수 있는 상태로 만든다. 즉, listen 시스템 콜은 TCP를 대기 상태로 만든다.
    - 서버 측의 소켓은 listen 시스템 콜 이후 대기 상태에서 클라이언트의 연결 요청을 받아주기 위해 backlog queue를 가진 채로 기다린다.
- accept() 시스템 콜
    - accept(소켓, 클라이언트의 주소 정보, 클라이언트의 주소 정보의 크기)
    - backlog queue에서 SYN을 보내와 대기 중인 요청을 선입선출로 하나씩 연결에 대한 수립을 해주는 시스템 콜
        - 선입선출 이후 3-way handshake를 수행한다.
            - client가 보내는 SYN = listen 상태인 서버의 소켓에 연결 요청을 보내는 것
            - 이후의 과정은 accept 시스템 콜 이후 진행하여 최종적으로 “Established” 상태를 수립하고 본격적인 데이터의 송/수신이 이뤄진다.
    - 대기 중인 클라이언트의 요청을 차례로 수락함으로써 데이터를 주고 받을 수 있도록 한다.
- 멀티 프로세스
    - 여러 개(2개 이상)의 프로세스가 동시에 실행하는 방식으로, 각각 독립적인 실행 흐름을 가진다.
        - “동시에” → 동시성 vs 병렬성
            1. 동시성(Concurrency): 은 CPU core가 1개(single core)일 때, 여러 process를 짧은 시간 동안 번갈아 가면서 연산을 하게 되는 시분할 시스템으로 실행되는 것. 동시에 여러 작업이 실행되는 것 같이 보인다.
            2. 병렬성(Parallelism): CPU core가 여러 개(multi core)일 때 각각의 core가 각각의 process를 연산함으로써 process가 동시에 실행되는 것. 실제로 동시에 여러 작업이 처리된다.
    - fork()는 멀티 프로세스를 구현하기 위해 사용되는 시스템 콜로, 부모 프로세스와 동일한 자식 프로세스를 복제한다. 생성된 자식 프로세스는 독립적으로 실행되고 부모는 자식의 종료를 처리해야 좀비 프로세스를 방지할 수 있다.
- 병렬 처리
    - 여러 개의 작업을 (실제로) 동시에 실행해 효율을 높이는 처리 방식
    - 멀티 코어 CPU 환경에서 하나의 작업을 분할해 각각의 코어가 병렬적으로 처리한다.
    - 여러 쓰레드를 활용하는 멀티 쓰레딩과 여러 개의 프로세스를 활용하는 멀티 프로세싱이 있다.